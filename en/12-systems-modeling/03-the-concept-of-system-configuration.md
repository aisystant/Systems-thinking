---
title: Concept of Systems Configuration
---

**Configuration** **of a system** is the current relevant state of the system (the system’s embodiment: all parts on all system levels) and their descriptions in their correspondence. Ontologically, it is the system itself, but in fact - it is a temporal part corresponding to some state of its construction in terms of the presence of certain versions of constructs. Usually, during various projects, many different options for possible parts of the system's embodiment are produced (if “in metal”, even manufactured) with varying degrees of success, and only one of them finds its place in the target system during operation, while the others remain outside the system – either as spare parts or simply discarded due to moral aging. There may also be many successful embodiments for subsystems, but not all are used in the target system (for example, a dozen pumps were manufactured, but only one made it to the pumping station - the others were produced, with some sold and some kept in storage as replacements in case the working pump fails).

Moreover, during the design phase, a multitude of different types of system descriptions and its parts, related to different time points, are developed by various agents. The project needs to understand: which variations of all the manufactured parts eventually entered the current system embodiment, and which description variations are relevant to the current state. Not all manufactured parts of the future system are used; some remain unused. Not all system description variations are implemented: some are rejected in favor of others that are more suitable for the system’s success, making the system more functional, reliable, cheaper, faster to manufacture, etc. If you apply the firmware of an old phone version to a new phone model – it’s not certain it will work. Such **configuration collisions** should not occur; all versions of both the system parts and system descriptions must correspond to each other. Therefore, the concept of configuration as the state of the system’s versions extends to descriptions as well – we only need descriptions that describe the current system configuration, possibly only of a future system (this is sometimes separately called **system description configuration**).

Modern manufacturing adopts an evolutionary idea, where the system is considered as a type of system, similar to the evolutionary view of animal or plant species.

Firstly, a type of systems or animals (a set, type) is represented by instances (unique physical objects) that are all genetically slightly different but belong to the same type. For example, the Boeing-737 system is thought of as a “type” consisting of a series of slightly different unique instances of physical airplanes. How to determine if the system refers to a “type” or a specific airplane by serial number? From the context, as there is no other way. If you talk about a Dell XPS 13 computer, you are referring to all Dell XPS 13 series computers and their development (they will be structurally quite different, with each year’s models having significantly varying configurations), or to the current computer with a serial number, but here the central processor type, memory volume, screen resolution can differ – these can be chosen at purchase. And all this will be Dell XPS 13, with some similarities. The same applies to the Windows operating system, the software on your computer. It refers to all similar versions of the Windows system differing from, for instance, iOS, or a specific yearly version, or even a unique version on your computer. How to know what is being referred to? From the context, and if unclear – ask again!

Secondly, one separately thinks about the meme (all system descriptions, living and evolving within creator organizations, analogous to the animal genome contained in each cell) and the phenotype (a set of properties of developed and embodied systems, for animals, it is the set of properties of an adult organism). In engineering, the principle of “continuous everything” is adopted today. Firstly, it is “continuous development”, which doesn’t stop with the release of the first version of the system as an MVP, minimal viable product, but primarily – **“continuous delivery”**, don’t confuse this with mere “customer delivery”, it is also already deployed with the customer, “continuous deployment” and further continuous testing. Continuous operation means creating sequentially different system versions with various configurations (sets of physical material parts and corresponding descriptions, following some alternative routes through creator tools – one version on one machine, another on a different one), and these versions have different descriptions. Thus, the properties of all systems differ. Even these final descriptions undergo multiple changes after refinements, bug fixes, addition of new features to the described system.

How to determine which of these description versions should be used by manufacturers for system embodiment? And if some manufacturers changed the system embodiment so it no longer corresponds to these descriptions, and some manufacturers work “as agreed” – can you be sure that a working system can be assembled from the produced parts? And which instance of the working system? Tesla cars are now developed within a production process where developers and the factory work on one production site, changes to the design are made without interrupting production, an operation at the factory can be conducted in two alternative variants according to A\|B testing^[<https://en.wikipedia.org/wiki/A/B_testing>], but compared not two variants of the whole car, but multiple times a pair of variants in different conveyor places. Each Tesla car thus has a unique configuration, it is not similar to other cars of the same brand, differing in many places. Likewise with airliners – slightly different engine modifications, seat configurations, control systems, but no two identical Boeing-747s in the skies. Considering that the system configuration is one of the specific states in terms of the system parts’ versions of the “system as a type” – this “configuration” runs on the roads for Tesla, and flies in the air for Boeing, it is not a configuration description running or flying, but documented in the database. The closest approximation to it – yet non-running and non-flying car or airplane, already assembled and tested standing at the factory, they are “in metal” but not yet operational. It’s only programmers who confuse the configuration of their “project documentation” (source codes) with the system's configuration (already working in machine codes). “Iron” system engineers must clearly understand that a system’s configuration, and its descriptions without configuration collisions – is very good, but insufficient for discussing configuration; system description configuration – isn’t the system’s configuration during its operation.

Errors related to some system parts and their descriptions being unknown, or known but not corresponding to each other in their current versions, are quite common – these are called configuration collisions (engineer slang for a configuration with such errors is “broken configuration”, an unpleasant situation, “iron” engineers usually say “the system doesn’t assemble”, because all parts are made – but cannot assemble into a system, “this round thing here doesn’t fit in this square thing there – unclear how it happened”).

A system’s configuration – is the parts of the embodied system and their descriptions; in modern engineering, every instance's configurations are unique. The configuration itself can be described (defined) and consequently documented (described). **Configuration documentation** is often shortened in speech to just “configuration” – and the difference between the system's composition (configuration) and configuration documentation needs to be determined from the context just like the difference between architecture and architectural documentation when the word “architecture” is used for both.

**Configuration management** is tracking that the system’s embodiment and descriptions are known and correspond to each other. This discipline lies in between managerial and applied engineering disciplines. A configuration comprises **configuration items** – the smallest parts into which the system is divided in terms of logistics. This involves the units of system parts and their description transfer from one work performer to another, from one process to another.

Engineers for the target system often have more detailed parts descriptions than needed for organizing the transport of work products. For example, each of the many billions of transistors on a chip is unique, but the configuration item in the electronics workshop is the chip itself, not these transistors, as separate transistors are not transferred to anyone.

To avoid losing these configuration items in accounting, to reference them in conversations and various system descriptions, individual designations (designations) are assigned to them. IEC 81346^[IEC 81346-1:2022, Industrial systems, installations and equipment and industrial products --- Structuring principles and reference designations --- Part 1: Basic rules, <https://www.iso.org/standard/82229.html>] is a standard offering a typical way of such description, considering the systems approach – multiple alternative system structures (functional, modular/product, placement, cost, etc.).

**System version** is its configuration as of a moment in time. System versions are named. Tracking version changes due to **changes** is needed to clearly indicate which of the numerous configurations arising and disappearing during the project is meant. Not all versions can assemble into a working system, often called **configuration dependencies/dependencies**.

In software engineering, there are also configuration description standards, but they usually don’t consider the systems approach and rely mainly on the idea of source code versions. Popular “naming systems” for code parts are Semantic Versioning^[<https://semver.org/>], attempting to change version names based on whether major or minor changes are made to the source code, but it is found that both major and minor changes can break the system equally in case of a collision, so a simpler and more reliable option is proposed: Calendar Versioning^[<https://calver.org/>], which marks the date of the last version change – making it easy to orient by version name on how long ago something was changed.

System documentation (today almost 100% electronic formats, often not classic “documents”, but databases) is always documentation of some configuration items (read: descriptions are always descriptions of some systems or descriptions of other documents' content, sometimes form; versioned documentation – the versions of some versions' system descriptions, versions of other documents), and its designations are usually created by appending the description type to the configuration item name. If for some reason it's necessary to describe three or four configuration items, it's likely talking about a system description of these items and thus needs a new configuration item created and described.

**Baseline** (configuration baseline) is an integrity-checked and administratively approved version, but more frequently seen as an anachronism in development today: integrity checks happen for each version, and there is no administrative version approval with multiple daily product versions.

**Change management** is often included in configuration management. Terms are combined: “configuration and change management”, but generally this is a separate discipline. Do not confuse it with organizational change management – how to change an organization without causing resistance and bringing positive results. Engineering change management is about decision-making on configuration changes to minimize configuration errors. Previously, there were 1. regular work versions with simpler changes, and 2. baselines with additional integrity checks for configurations. Today that’s an ancient story, different change management approaches are used, like trunk-based development^[<https://trunkbaseddevelopment.com/>] (trunk – just the version tree trunk, without branching). Interesting observations emerge, like the quality of systems for which a change approval board didn’t differ from systems without such board evaluation: freezing configuration changes slowed development but didn’t improve quality. For example, freezing new features' configuration didn’t increase quality but freezing bug fixes did, proving beneficial. Everything is alive, everything changes for potentials' better, and intensive testing for each instance/version will show if errors occur (one instance – one version).

In any case, you need configuration management, knowing at any moment which (of all possible variants) parts are in the manufactured system, by what descriptions they were produced – ensuring no collisions, errors, and contradictions when assembling parts into a system and merging particular descriptions into a system description. It’s very bad when Team A develops their part considering a meeting result agreeing a part size as 220mm, but Team B continues developing the case with the old size 180mm – unaware of the meeting. At assembly, this part and case meet: here’s a configuration collision: the case's expected part size and the manufactured part size differ by 40mm, the system “doesn’t assemble”. It’s best to catch this before Team A already manufactured the part and Team B the case. Configuration and change management aim to prevent this from happening.
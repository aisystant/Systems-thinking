---
title: Applied Functionality vs. Universal Design
---

A common mistake in systems development is ignoring explicit functional modeling of the system: documenting schematic diagrams, descriptions of subsystem interactions, answering the question "how does it work," "how does the method change the state of objects." In electronics and electrical engineering, as well as in continuous/flow production^[<https://en.wikipedia.org/wiki/Continuous_production>] (chemical and energy enterprises), it is usually customary to draw such schematic diagrams (often documented through diagrams), where functions/processes or role/functional parts/units of the system are explicitly marked, or even both together.

But this development method, which requires mandatory drawing of functional diagrams, does not exist for all types of systems. For example, in software engineering, it is not common to draw functional/flow diagrams in most projects, nor to create such textual descriptions in a formal modeling language, or even in pseudocode.

For example, programmers think about the functionality of their programs, but they somehow don’t make schematic/conceptual diagrams of their work; they keep snippets of these schematics exclusively in their minds — and therefore, these diagrams cannot be checked for gaps, errors, or to discuss the functioning of their systems with colleagues. This does not mean that functional/flow notations do not exist, for example, data flow diagram^[<https://en.wikipedia.org/wiki/Data-flow_diagram>] and even dataflow architectures^[<https://en.wikipedia.org/wiki/Dataflow>], which form the basis of the so-called "reactive programming"^[<https://en.wikipedia.org/wiki/Reactive_programming>]/"stream processing"^[<https://en.wikipedia.org/wiki/Stream_processing>].

In the source code of programs, however, these "schematics" with their flows are not visible: the programming paradigm often does not involve a dedicated showing of the functionality of parts of the program, plus this functionality is significantly cluttered with description details sufficient for code execution. In advanced circles of software developers, this is not the case, and functional descriptions (most often obtained within the framework of domain driven design, DDD^[<https://en.wikipedia.org/wiki/Domain-driven_design>]) are documented, but so far this is not a common culture/practice, more like a pleasant and rare exception to the general practice.

This view of the system as some flow from inputs to outputs — it turns out to be important for the enterprise as a system. Thus, operational management is just a functional (sometimes referred to as logistic, "transport") view of the enterprise as workflows, flows of components and supplies (ERP, enterprise resource planning works precisely with planning these flows, if there is no flow planning — then it's not ERP in its original meaning).

Neglecting functionality is a typical mistake of engineers and managers united in a project. "Tech entrepreneurs" or corporate managers converse with external project roles/stakeholders and usually identify their needs, but no one deals with the concept of use, that is, the basic use scenarios of the target system — engineers immediately move to the system concept, which is not yet clear what it should do (its function in the higher system is not clear). Including the use scenario, we note, not only the happy path, that is, the behavior of the system when everything goes well and there are no surprises.

But surprises are always present, and they need to be cared for in advance. The design engineer in such cases creates a modular design (that is, provides in the design for some replaceable modules with various expected important characteristics in their services at the moment of use, but these modules will have some identical connection interfaces). Functionality there is provided "for growth," as services of modules implementing subsystems, which, in his opinion, can provide all possible functions at the system level without additional product improvements, if suddenly needed.

For this, the engineer connects typical constructive elements through typical interfaces from the most common and simple standards, hoping that after eight iterations everything will somehow settle down itself with functionality (there will be feedback from dissatisfied customers!), and the project will eventually be successful. But this is not elegant, not lean: extra functionality is added, the system due to this usually becomes more expensive, takes longer to manufacture, but the necessary functionality may not be in the first iterations, the first iterations will require rework, they will not represent MVP.

Note that this is roughly how the "broken telephone" works: some people (who are not trained in Systems Engineering) talk to the customer, they formulate and rigidly fix the requirements with their obligations (not in the form of a hypothesis about what the customer needs from the system), and then the system is developed by completely different people (who are trained, but have no contact with the customer — and therefore the system's concept turns out to be poor, the hypothesis can only be checked after presenting the already finished system with a wrong set of functions to the customer).

The error of the absence of functional parts of the system in the system concept is also easy to find: in the system concept with this error, there is no reflection of the subject area for which the target system provides the service, there are no service items going through some states during processing. The service is named (however the people involved with the target system might name it, not the higher system), but there are no service items in the higher system (what the module as a subsystem performs within the higher system).

For example, in the concept of an information system of a store, there simply appears a "database" (an overgeneralization for anything), not "product prices, discount rules, purchase history." It's clear that all this must be stored somewhere, but it is not a fact that in the "database" drawn by the programmer on his very first diagram (part of it, for example, may be obtained through an API of some service provided through the cloud, and discount rules may be stored in a configuration file or even turn out to be an artificial neural network), and not a fact that even the "database" will be one.

Now feel the difference:

- A manufacturer defines the pump unit service as "increasing pressure," whereas the client needs a function "lifting water to the upper floors" (and it is also necessary to calculate the required pressure increase for this and what else needs to be done, for example, by installing two pump units so that the breakdown of one constructive does not lead to interruption of functioning),
- A manufacturer defines the hammer service as "strikes," whereas the client needs the function "driving nails into boards," whether by "strikes" or "pressing"
- A manufacturer defines their program's service as "computation" (hoping that the built-in programming language will provide "any computations"), whereas the client needs a function "calculation of a calibration curve" from the program, but "out of the box," without writing programs in the internal language.

**Functional diagrams will contain the names of functional parts or functions, while** **constructive/modular/product diagrams, disguised as functional —** **will still contain the names of the most common services, and usually indicate not flows and ports, but standardized interfaces as places/channels of service delivery.**

It is difficult to explain to a programmer the necessity of making functional descriptions as part of the system concept because they think in terms of components/modules/products/frameworks/platforms, which, in their opinion, are absolutely universal and will support "**any function."** **Any-any?** Remember, you should double any **universal quantifier found in system description** **—** **"each," "every," "any," "all,"** **etc., and put a question mark after it, doubting that universality.** Unfortunately, universality will not happen. But the disappointment will not be at the beginning of the project, but closer to the end — when it turns out that there are no universal application software systems, just as there are no universal "hardware," "human," "social," etc., systems.

**Architecture (architectural decisions related primarily to the division into modules and organization of connections between modules to support acceptable values of more or less uniform architectural characteristics for very different systems) is recognized by the programmer, but the system concept** — **no; functional decomposition at them** **is big-level "in the head," and then immediately goes into the source code, "the worker," and this is a mistake** **in the working method.** While the importance of architectural work is already recognized in large projects, the concept of architecture has undergone significant changes (more details in the "Systems Engineering" course) and the work of an architect is put in opposition to the work of a developer. Even new terminology for components/modules appears, reflecting architectural considerations: **an architectural quanta** as an autonomously deployable construct with high functional cohesion within it^[<https://www.oreilly.com/library/view/building-evolutionary-architectures/9781491986356/ch04.html>]. Further, we expect such considerations on how to divide a system into constructs, including architectural quanta, to transition from large corporate application architecture to hardware engineering, and much more. Roughly speaking, a vehicle with a trailer has quite a few constructive parts, but here the vehicle and trailer are the architectural quanta, deployed autonomously.

Even aside from architectural work (performed by the separate role of the architect by architectural methods, not the developer's, and it is work on the construction, not functionality), software developers usually make many mistakes relating to functionality. Developers tend to act as "under-architects," focusing on "universal modular constructions," but forgetting to delve into functionality — but developers are ultimately responsible for accounting for functionality, not architects.

Here is an example illustrating what happens in the head (or computers, or heads and computers, because not all developers today are human) of developers using an example of working with a "hardware" system — but of the same kind as programs: seemingly super-universal in form, but very concrete and unique in content. "Commercials" at the factory dragged some of their product ideas to the design engineer in the "technical department," and the design engineer thought for a bit and came up with some ideas that the "commercial department" formalized into proposals for a new project:

We face the task of fine chemical synthesis of dimethylfluoromethylchloropentylbenzene-titanium for pharmaceutical industry purposes. It is known that it is difficult to synthesize, and many impurities are produced during synthesis, from which people die. Therefore, we will offer pharmacies such a pure product from which people will not die, and the marketing will be original: through the cleaning ladies of medical institutions, who will throw our brochures to doctors, and also heart-to-heart conversations with patients in queues to doctors. To obtain pure dimethylfluoromethylchloropentylbenzene-titanium, we will use four steel reactors connected by pipes with a diameter of 56mm, the last pipe is Teflon-coated. We will order the second reactor from external contractors. The purity of the resulting dimethylfluoromethylchloropentylbenzene-titanium will be monitored by an independent expert service. All four reactors must pass a pressure test of 156 atmospheres.

This description contains no ideas about which specific impurities have the maximum harmful effect, how to obtain purity from exactly these impurities (and not just any impurities — harmless ones do not interfere) dimethylfluoromethylchloropentylbenzene-titanium, what raw materials are needed and whether they are available or they also need to be synthesized under the project, further chemical reactions starting from available substances, i.e., detailed investigation of what happens in the reactors.

Now imagine a design engineer in the technical department, to whom representatives of the commercial service (marketers, account managers) come and say that he will need to solve the task of chemical synthesis, but it is not yet clear which. And they will someday later, but not right now, hire a chemist who will clarify everything. The engineer agrees and takes on the case: it is immediately clear to him that reactors and pipes will be needed. Reactors are not clear in number because it is not clear how many chemical reactions there will be in the synthesis. Therefore, it would be better if there were many reactors. He chooses the number 4 as "not very few, but still not too costly," guesses that there might be a tricky endothermic reaction in this synthesis, but he himself is unlikely to design a reactor for such a reaction. So he gives the task of designing this "tricky reactor" to external contractors and writes honestly about it. Although external contractors already asked what about masses and temperatures, nobody can give an answer yet, so the contract is planned without discussing use scenarios — but contractors certainly do not refuse the order, they say "I will make any reactor." The word "any" does not scare anyone, as there is no chemist who could say what will happen in this reactor. There are only hardware engineers well versed in steel grades and welding, and marketers talking to doctors and pharmacists. The design engineer expresses the end result in the above abstract description of the system, which is unlikely to lead to success; almost all decisions hastily made then will have to be taken anew: discussion of the construction cannot be placed ahead of the discussion of functionality.

In the case of reactor and pipe hardware, it is obvious: the probability of producing pure dimethylfluoromethylchloropentylbenzene-titanium in this situation is zero. But **in the case of software, it somehow seems that the task can be solved this way. And so they write about** **"servers"** **and** **"databases,"** **but how there will be processing of what information there, and why this processing will suddenly be better than the competitors', or even generally possible, this question does not arise. Exactly as in the previous task, where there is no chemist, only welders and high-pressure body specialists. They will definitely** **make a software** **"universal reactor,"** **but what about the purity** **of the "information substance"** **or even just setting off the necessary** **"information reaction"** **(words** **"information processing"** **or** **"computation"** **are written without any clarification, what exactly), and obtaining raw data (or original information? data! because information means something, and data here is like raw materials —** **one can ignore their content) —** **this is not for them**.

In the project of obtaining pure dimethylfluoromethylchloropentylbenzene-titanium, there is still no chemist, no one can support the conversation about chemistry or figure out how this chemistry influences impurities, and the impurities on the patient's health. **In** **the context of conversations about reactor and pipe** **constructive** **by this time it's already possible** **to forget that the situation itself** **is about medicine, the needs here are in the patient's health** **(the target system here is the patient: live tissues surround it at the moment of work, and reactors and pipes are in the systems of creation, "on the side" of the target** **system's separation/environment, in a different time, in the time of creation)**. It is, of course, necessary to make the iron construction of "our system," but it is functional system work that should be done, which should perform its function in the graph of creation! It is necessary to trace a strict logical chain from the target system (synthesized substance) to our system (made of pipes and reactors) — through functional description, that is, chemical reactions describing the functionality of the target system (how it behaves in the patient, time of use), and further to deviations from the conditions of conducting reactions in the reactor leading to the appearance of harmful impurities (time of creation). In this case, the subject area of the functional (chemical) considerations of exploitation time — in fact, the client's, and the final constructive (pipe and reactor) considerations — the subject area of the manufacturer-contractor, the time of creation. Essentially, this reasoning is even not a very complete pass through the system mantra.

Returning to programming and typical mistakes of developers insufficiently concerned with functional descriptions. Alas, it is usually not possible to obtain a functional description, which tells what substantively happens with customer information in corporate information systems, the first time. A couple or more iterations with roles/functional parts of the system and their assignments/behaviors (functions), but once obtained, the structure of components/modules/platforms/products/microservices is quite reasonably and substantially corrected, mainly handled by the architect.

For "hardware" projects, iterations with gradual refinement of descriptions are also needed, based on obtaining additional information in these iterations. In our example, after a detailed investigation of functional descriptions, the number of reactors will be changed, unnecessary pipes will be removed, additional research on the availability of cheap product purity sensors on the market will be carried out, a contractor will be found that writes control software for closing-opening the gates on reactors to manage the synthesis process based on the readings of the sensors, etc.

First, one needs to deal with functionality: what happens at the moment when the system works/functions (the word "functions" here is not accidental! Functions and functional parts are the focus! This is the area of interest for roles responsible for the system's operation!), not when it is being assembled from construct parts of products/modules/items/platforms. Then, in the course of modular synthesis, one must still consider construct parts and placements. But that's later, and first, a qualitative functional decomposition, functional/systems analysis, is needed.

**Consideration of** **functioning** **first, and construction second, is an important part of Systems Thinking: first, you need to discuss in detail why these constructs are needed and how they will work, and only then consider from what they will be assembled.**

In modern engineering, however, it is not customary to perform top-down functional decomposition since it is very difficult to overcome the consequences of those decisions that will need to be changed when subject matter experts of a particular function take on the case. Therefore, it is customary for visionaries (this role is usually performed in product manager positions) to come with some ideas about what and with what priority to add to the services/functions of the system in its environment, followed by architects, who roughly estimate which constructs are most likely to support this functionality in their interactions — but do not perform functional decomposition themselves. Then, they invite people from the teams dealing with the selected modules for detailed functional consideration at the lowest level. And iterations go with them. Thus, rough functional decomposition and modular synthesis are performed by architects and visionaries (in the person of product managers) at higher levels, while detailed consideration immediately occurs at the lower level, by those well-versed in the subject areas of these functions/methods/services, knowing the specifications of these method items.

Of course, these discussions pertain to the engineering of anything, not necessarily "hardware" or software. For example, one can consider applying this reasoning to dancing. Simply waving arms and legs (with a margin! More waves, and the waves themselves wider!) will not satisfy anyone. Each wave should be understood, why — what emotion or lead signal is expressed: what do they want to say with this wave, demonstrate, what result is expected. Then the wave will be chosen appropriately (sharp, smooth, large, or short, with a hand or leg — exactly to a necessary function, not "standard with countless variations due to parameterization"). If your dance does not require a straight leg wave to the ear (and with "a margin for any choreography you may encounter," as done in the creation and development of classical ballet dancers, about ten years of training), you can save many years of life. Less universal waves "for the function," considering the subject area of a particular
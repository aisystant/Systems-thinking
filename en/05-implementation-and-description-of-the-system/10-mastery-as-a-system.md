---
title: Mastery as a System
---

In order for a client to get the result of an organizational process executed by some organizational unit in its organizational role (for example, an internal client can get salary::money::system, accrued::organizational process::behavior and issued::organizational process::behavior by the accounting department::organizational unit as treasury::organizational role), the application/program/software::system needs to be configured, obtain source data for it, and train employees to work with this software as a tool (literally like teaching a child to hammer nails—not missing the target and hitting with the hammer, not the fingers). Then, **verify not as much** **the software, but the work of the entire** **organizational unit/service/provider** **as a whole, including the software** **assigned to this unit.** The software thus becomes part of the department like a hammer becomes part of an organizational unit of roofers who will use it to build the roof of a building.

**In the modern world, the reverse can also happen, where the software acts as the organizational unit, and some people (operators, development team) are included in it, but the work will still require not only the software but also the people involved in it.**

To reiterate: no one cares about the excellent performance of the payroll program; what matters is the payroll itself (imagine it as dividing a heap of physical gold into portions to be distributed among employees)—and if payroll does not occur, it will be hard for the software development team programmers to explain to the unpaid employees that everything is fine with their software, and that the rest of the accounting department staff is at fault for incorrectly filling in the fields of this program and pressing the wrong buttons. Employees do not care whether the software is inside the accounting department or the accounting department is inside the software; they care about the end result of the software's operation!

Do you hire an excavator to dig a trench and the excavator operator along with the excavator (the person who plays the role of the excavator operator with his excavator)? Or do you invite an excavator operator as a one-man unit, which includes the excavator? I think it's easier for you to view it as an excavator unit that includes an operator, the "excavator control software executed by a live computer." What matters is not the operator but his excavator; the expected result is from the excavator! In the operating room, we usually care about the surgeon and anesthetist, but in the CT scan room—primarily the CT scanner, while the rotating teams of operators there are seen as part of the CT scanner unit, consisting primarily of the CT scanner with a few additional people.

If your company has AI agents or powerful server software that yields primary results, it is often unclear whether you ascribe this software (including AI agents) to the people, or vice versa—people to the software. **In this regard, people are also "universal robots with specialized software inside them for working with other software or equipment."**

In software/application/digital twin development projects, there is often a need to develop not only the software (traditional or neural AI software) existing in computers but also the neural software that exists in people's brains as processors. This software/program, executing the algorithm/theory/discipline of some work method as a physical object, we will call the **mastery** of performing a certain "role behavior"::"work method." "Role behavior" is the behavior of an **agent** (which consists of an **organism** and/or **equipment** in the case of live agents-people or not-so-live AI agents, as well as a **personality** and/or **software/tools** as a collection of all software/programs running on this organism/equipment), taken as part of the behavior of only mastery from the personality composition, which helps the personality play a role. Roughly speaking:

-   Person::agent = organism + personality (personality as a collection of various types of mastery, "all software, all brain programs")
-   AI agent = equipment + personality (personality as a collection of various types of mastery)
-   Mastery::system = ordinary or neural program::system running on the AI agent's equipment or human organism, implementing the algorithm/theory of a work method.
-   Method::behavior—generalized algorithm/theory by which mastery operates, and the tools needed to execute the method (say, for trench digging, besides trench digging mastery, a digger needs either a shovel or an excavator—tools enabling the application of mastery).

In a corporate software development project, there will necessarily be:

-   accounting for **hardware** for this software ("hardware" or "virtual machine"—software containerization, considering that part of the software executes on a server in a data center, while another part may run on a phone with a tiny screen, etc.—everywhere has its OS, but hardware must be considered!). The program works as part of a **software-hardware complex**, not by itself!
-   actual development of the target **software**, as everyone recognizes.
-   creation of **mastery** in people's brains (training to work with the program: you need to "create" those parts of different people's brains in various roles, capable of doing something useful with the program—create the mastery of working with it). Note that you will also need to account for the people’s brains—if you are not given people, you cannot create mastery in them, just as with hardware for "software-hardware complexes."
-   Creation of **mastery** in AI agents (this is just emerging, but there are unique aspects: current AI agents cannot be programmed like software, nor trained like people, but mastery to work with your software will be required from them)
-   Creating initial **data** (data engineering) and distributing them across various **carriers** which the program will work with. Moreover, the program will produce output data, which also needs to be known where and how to post.

Do not skip these parts! They are physical; they also need to be "designed" and then "created":

-   the software itself is "developed" during **software engineering/software** **engineering**,
-   to create mastery within people's and AI agents' personalities, they must be **trained** (and develop methods by which this will happen, and methods of verifying training—in detail about this in the course "Personality Engineering"),
-   additional classical software needs to be **configured** in terms of using its interfaces (and check whether everything is set up correctly).

![](10-mastery-as-a-system-15.png)

But what about the people who work with the programs? Very often, the embodiment of the target system of a project is some part of the organization that needs to do a specific job—issue a loan, calculate payroll, manufacture a part. If it turns out that the program works "correctly" from the developers' perspective, but people in the organization cannot work with it for any reason, the program's work will not be considered proper. What is the point of the payroll program working if people cannot interact with it? If programmers want to receive payment for their part of the job, they must ensure that someone works with the people and that the jointly trained people and configured programs (and data for the program, which can be a separate problem and may require individual performers) are submitted to the customer. The payroll calculated, the quality part manufactured—leading to these important goal results, while the software is submitted within this organizational unit's (subdivision, project group) work.

Conduct similar reasoning for training people as for computer programs. Learning books, videos, computer courses (e.g., our course "Systems Engineering") are only documented outlines of desired post-training results. The goal of learning is a piece of a trained brain, let’s call it mastery::software::system, and it works (a system behaves in some way during operation!). Mastery as a system, upon entering the goal environment, is activated analogously to a computer program and performs the computations/problem-solving it was trained for. The brain is a processor, mastery acts as part of the processor. It doesn't matter which exact parts of the brain implement mastery. The important thing is mastery is implemented by the brain, not by the cosmos, extraterrestrial forces, embodied spirits, or other unlikely causes. Read books, watch videos—they merely set an outline of expectations from the brain later in real-world application situations. They train the neural network, increasing the likelihood of physical brain process (with state change!) computations in line with training outcomes.

![](10-mastery-as-a-system-16.png)

The only thing is, you don't need to talk about neurons and training them; this is not the detail level (not the systemic level, not the system size discussed in training). But conceptualizing training results as a trained brain area "mastery" forces us to consider how this training is physically configured (the brain area must be located somewhere during training, data must be fed in and results computed), and how the training result behaves physically as a system (the mastery must have an appropriate physical environment for it to be applicable. For instance, being able to perform flips on land is inappropriate underwater but is useful in a circus).

Suppose during mastery use, a person is in a machine shop, amid deafening noise from surrounding machines. Will mastery (software/neural network program/trained brain area) kick in without a reminder? Will it accurately and seamlessly produce the intended thinking trained (without prompting)? How much time will it take? What happens before and after this moment? Transitioning to a physical system (an area of the brain ready for action/thinking) proves productive even in training scenarios. There is much description in training, but they are not the main point. The main thing here is an end physical object: a system with prescribed properties and known behavior during use.

What is the target system in a bridge construction project? The bridge, naturally! But to build the bridge, you need a project organization to carry out its creation, firstly in design (typically in a city, a design institute), then in construction (thousands of people in an open field!). Only then can you enjoy the bridge. This is the entire **creation chain: create the creator, then the creator creates the target system.** These can be not only chains but more branched graphs, with many links (creator of creator of creator). Imagine, for example, any of the programmer projects common within bridge construction. Why do they exist? Why all this software? For the bridge to ultimately appear!

System thinking demands that we trace the entire chain from the software used in the bridge construction project to the bridge itself. If you do not trace it, the software proves unnecessary—even if developers want payment for it, particularly for its unneeded "features" of this software. If the software's capabilities are underutilized, they may not work as expected, but developers will still demand payment if the connection between software capabilities and target bridge implementation is hidden. If the target bridge has no use for this software or its capabilities, it means the software can be scrapped, the project dismissed, payment avoided. **System thinking tests if you are engaged in unnecessary work.**

System thinking requires contemplating this from the start, not during the non-signing of project acceptance acts for "software creation." **Usually, software** **as systems are not needed by anyone per se, they are needed only as part of other systems** **—and you need to ensure the development of those other systems in whole, and software** **only as parts of those systems** **or systems making those target systems** **—deal with all chains leading to reality, the physical world.** Do not confuse the photograph with the photographed subject, the book with the living world, the software with the real world described and changed by the software.
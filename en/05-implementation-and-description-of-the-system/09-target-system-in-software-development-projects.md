---
title: Target System in Software Development Projects
---

How to find, out of all possible systems, the target system that programmers ultimately produce, the system whose creation will count as the project's success ("everyone is satisfied, no one is offended")? Often, even a working program ends up working with descriptions and documentation of some other system than the actual system that alters the physical world—and one must mentally trace the chain further until finding the system that indeed changes something in the physical world, not just in descriptions!

To start, simply go through the list of errors from the previous subsection. Although there may be many more errors, even this short list usually significantly advances understanding. Suppose, for instance, that your program is a digital twin, then you need to find its physical twin, and the system will consist of both the digital and physical twins. Accordingly, change the project: the delivery of the program should not be just an unconvincing demonstration of the program itself with its database as a digital twin (but this is precisely "a demonstration of just the program, and nothing more" that developers would like: "the paper will bear anything," detached from life, the software is free to fantasize its results, the success of these fantasies is easy to show), but a demonstration of the proper functioning of the physical twin under the control of the digital twin. Demonstrating changes in the physical twin under the control of the digital twin is much harder than demonstrating a digital twin detached from reality. But only this will be a real success of the project, for which they will pay. It is another matter that when it comes to a rocket or a bridge, or even a patient in a hospital, the physical twin is obvious. But how to find it when it comes to a web of objects and their relationships in some enterprise? What could be the physical twin there, whose functionality needs to be demonstrated in tandem with the digital twin?

The first **mental move to find the physical twin is not to look at the algorithm (described by the source code) but at the data of this program (often stored in some database). This data describes some system (including processes of this system, i.e., changes in states of the system)—this system is usually the physical twin.** This system described by the data of your program will be the embodiment of that system with which all people surrounding the development will be concerned! This mental move does not work in 100% of cases, but it can be a good start for finding the target or "our" system when there are many programmers around. In a weaker version, this same move is good for information objects (reports, models, databases, etc.): what do these objects describe, which system? This system is of interest, and the information object itself is the main concern only for the development team, while others are interested only in connection with what is happening to the system described by this object.

If we are talking about travel accounting software, then the target system—the one described by its data—will change (be created, destroyed) as a result of the program's operation. This is a business trip. Yes, a business trip seems like "riding and living of the business traveler," but it is assembled from different objects up to the sup-system in which this ride occurs (like a "dance performance" from "dancing of the dancer") and immediately it becomes clear how to describe and account for it in the computer. To do this, one simply needs to account for all objects entering into the business trip (relationship of participation/part-whole/composition)—people in the role of travelers, tickets as descriptions of journeys ("travel documents," with different nuances regarding paper and electronic carriers for these documents), often including hotels and their descriptions—payment documents for accommodation, baggage with its payment and documented descriptions ("baggage receipts"), and so on.

And here one must not miss because "trip"/"business trip" can mean different processes::behaviors or events::system (and you need to decide—do you consider these as processes, or as systems?):

- The one who sends on a trip (conditionally: "boss") calls "trip" the work that needs to be done somewhere in another city. Part of this work is the agent has to get to this city first, but this is of little interest.
- The "traveling" agent considers "trip" not so much the result of the work (for him it is simply a "result of work") but the "trip" itself: flying on a plane, traveling by bus, staying in a hotel, eating.
- The "accountant" as an agent considers "trip" not so much the entire "trip," but the "accountable part of the trip": not any travel, but only the one that will be compensated. Say, traveling to the city will be paid, and moving around the city—not, while the "traveler" considers it all a "trip."

Since different agents consider the trip as different processes or different systems—it is necessary to give them different names (say, "remote work," "business trip," "accountable part of the business trip," and abandon the word "trip" as confusing) and teach different agents to use these names to avoid confusion in conversation. Then ask the question: the software that helps to "arrange the trip"—which of these three systems does it help to create?! Of course, it will be completely different software or parts of one software working as digital twins (or shadows, or models) for different target systems: some help the boss with "remote work," others help the traveler with "business trip," and third help the accountant with the "accountable part of the business trip." There is a suspicion that for all so-called administrative processes there are at least three such considerations, which is why it is difficult to develop software for enterprise administration: everyone gets confused due to not distinguishing different systems under the same names! If you find different objects (pairs: systems and their behaviors) in the physical world (4D extensionalism) and give them different names—the confusion ends, and all project participants quickly agree.

If it concerns software for a CNC machine, then the target system is the part described by the data of this program. The program describes the work of the machine, and the machine is needed to obtain the part. The goal is the part, the money from it, and everything else is just a chain leading to this goal. If the software works well but the part turns out poorly—there will be no money. So with software (including **skill** as "program for people and AI agents" and even more so **personality** as a set of all kinds of skills of one agent) as target systems, one needs to be careful. This we will discuss in detail in our course, when we will discuss the target systems of the project.

In the world of software (and the whole world is gradually becoming a world of software, especially considering modern AI neural network software and software in people's heads: personality is software on the organism's hardware) there can be such strange system implementations as sessions—learning sessions, or gaming sessions. For instance, a gaming session consists of the player in the state of the game, the game server that remembers the state of the game world, the working program on the phone, which is controlled by the player on one side and the game server (via the internet) on the other side. All these objects mutually changing states—this is a gaming session. All employees of the gaming company will be happy with such a definition of the target system, because gaming companies sell these gaming sessions, increasing their total time! Notice that none of the other systems mentioned here will be sufficient for a full description of what is happening in a company trading computer games on their servers: neither the player in the state of the game, nor the server software, nor the software on the phone, nor the software of the payment system. Payment usually goes precisely for gaming sessions, with slight variations, and until you describe the working object "what they pay for"—the conversation with the company's businessmen won't flow!

Often there is confusion when the software represents a "marketplace." Not only is the software of this "marketplace" considered the target system, but they also ignore the data for this software, all the people servicing this marketplace, the clients of this marketplace, all possible intermediaries and providers who work with this marketplace to ultimately achieve an embodiment of a system for which someone will agree to pay. No one will pay for a "marketplace," it is just one of the parts that will allow earning: the marketplace produces what is needed by the people around it, and the target system will be what is needed by these people, created whether by this marketplace or any other means—it is unimportant.

For instance, the marketplace can produce "delivery." "Delivery" is not the process of "delivering," but some product (a thing!), located directly on the doorstep of the place where this very delivery is intended. This "delivery::system" at the moment of its use, that is, "the client took in hand the purchased product"::"process of use" (to reiterate: not delivery::process, but the final state of the physical world: delivery::system as "product transferred"::state and processes of transportation already conducted to the owner's doorstep and transfer of the product into possession) is the target system, it's for this that they pay, it's embodied in the physical world, it's produced, and everything else is just chains of descriptions in the "marketplace" and other systems creating this target one. "Delivery" will bring irreplaceable benefit to the clients, and everything else will bring irreplaceable benefit only to the various developers—they will get money from clients for the timely received "delivery." Notice, we didn't write "timely performed delivery" here, as this implies "delivery::work::behavior," "work" is usually performed. Admittedly, there's also the usage "performed" with systems, for instance "an artist completed a painting for the holidays" means that he completed all work for creating the painting by the holidays. So "completed the delivery on time" could also be understood as "completed all work for creating the delivery on time." You can speak in various ways if you track types. If you don't track types—you will confuse yourself and others.

Usually, when **discovering the target system** some interesting assumptions are made in 30-40 minutes of discussion. But in a week or two, these assumptions need to be clarified; quickly identifying the target system usually doesn't happen. For instance, "marketplaces" as service providers for making "delivery" from a "product" somehow do not work if considering only "delivery" as the target system created by the "marketplace," because transportation goes both ways: it's "delivery for payment" (the deal concludes when both payment and product delivery occur). The "marketplace" is only needed when it financially guarantees both the supplier and the buyer precisely this "delivery for payment." If it doesn't guarantee, then "just Google" does an excellent job of mutual searching for buyers and sellers, and there's no sufficient competitive advantage over "just Google," which is why the "marketplace" remains a utopian idea. So it's necessary to be very attentive to what the target system is in the project: the project's success is directly connected to the choice of the target system.

Can it be considered that all typical cases of target systems related to software are listed here? No! The world is extremely diverse, there are countless types of target systems, new business models emerge daily, bringing new types of target systems with them. The physical world changes more and more intricately, and systems thinking allows us not to get confused in this sea of descriptions and yet **focus on the main thing: what changes in the physical world, what is the embodiment of the system, what is the goal of the entire large (and not just your small part) project, for what people will be willing to pay.**

All these considerations easily transfer from the world of algorithms to the world of data. Half a century ago, there weren't even personal computers (the first appeared in 1980), and some twenty years ago it was still assumed that the world would be taken over by complex algorithms that would cleverly process relatively simple data in databases. Today it has turned out that modern software is shifting towards working with simple algorithms over complex data. Even in AI algorithms, this principle worked: the simplest neural network algorithms over complex weight data of neural networks achieve huge success, provided there is enough computing power to execute these simple algorithms (hard lesson
Sutton's^[<http://www.incompleteideas.net/IncIdeas/BitterLesson.html>]).

Since complexity is shifting from algorithms to data, system thinking interests not only software engineers but also data engineers. One should never forget that data are ultimately descriptions of some systems. Even in large language models, their data is a description/presentation/presentation of our material world as a system, only in a compressed model of the world—the result of a learning process. But at the moment of their processing by some program, they themselves become part of that program's system, they change their state, they can vanish, they behave like a "thing." So data for processing by a program also needs to be "crafted" from primary descriptions. And when we are interested in how to get a useful result from the data, just like with programs, we need to learn to craft them from the original data—and we will, by analogy with DevOps, talk about
DataOps^[<https://en.wikipedia.org/wiki/Dataops>].

Systems thinking is thus needed by both programmers and data processing specialists, and considering that skill and personality are also programs, it is also needed by AI specialists and those who work with people. Due to deeper division of labor, it is easy to lose sight of the fact that the most diverse professions are engaged in the same thing, can be supported by the same ways of thinking.

Systems thinking will help software engineers, data engineers, data center admin engineers, managers of all these numerous roles to negotiate with each other, and it will help find and train employees to work with their software and data, all those employees affected by this software and data. Software systems (at the moment of the programs' work), data systems (at the moment of data use), personalities, and skills within them—all these are systems, in the world of software systems thinking is applicable no less than in the world of iron systems, living systems, or organizational systems. **We must not overemphasize the programming part** **(software engineering and data engineering), always remember the subordinate role of software, and the primacy of the physical world that is described and changed by software** **in computers and heads, including data of this software—and everything in the project of creating information systems will then be in order.**
---
title: System Concept and Architecture
---

Very often, those who describe a system want to specify not only the external properties of the system, to describe not only the boundaries of the system and its behavior as a black box, but also to indicate some details of the internal structure of the system: to define the parts of the system (subsystems), to point out the process of subsystem interaction. In this case, the system is referred to as a "**transparent box**," where some subsystems, their properties, and behaviors are considered known. This can be considered specifications for the system concept: what behavior is expected from the internal parts of the system (their operation time, functions of the subsystems), which parts of the system's design (subsystem design) can realize this behavior, while also taking into account spatial aspects and total cost considerations. **System concept** describes the "transparent box" — these are at least four interconnected mandatory types of system descriptions, but more often these types of descriptions cover more areas of interest.

In any case, we should start with at least two: functional and constructive descriptions in their interrelation. Suppose you are preparing to make a door, and suddenly your external design roles say: "The lock in the door must be made of titanium."

The word "must" indicates a requirement, not a hypothesis, and this is alarming. What if you find better material? Why did this need to be specified, what in the door's behavior scares the one describing the door? What broken telephone effect occurred here, who set the usage scenario, resulting in this requirement? Why is there even a lock in the door, as you didn't suspect that the door needed to be locked and unlocked: this was not part of the usage concept. We understand that this describes a **restriction** on the developer's freedom: one developer::role indicated to another developer::role what should be inside the system, so this restriction could be taken into account in the system concept development. Question: Where did the developer::role come from in the external project roles? Sometimes developers of the target system on the client's payroll are called "client engineering," and they are paid precisely to create such restrictions on the freedom of external developers — for example, to prevent external developers from being tempted to overly cheapen-simplify or price-raise-complicate the system design.

Usually, the project organization (for example, a group of several teams) agrees with the external client on the functions/behavior that the target system should perform as a black box, the properties of this black box, i.e., the developers agree on the usage concept (most often not the entire concept but certain usage scenarios for specific "features" to be implemented by a particular team), and the system architect agrees on the architectural characteristics and their acceptable values for all developer teams. It's not a fact that these hypotheses about the system concept and acceptable architectural characteristics are formulated by the client! This is joint work with the client. How the system is arranged inside, i.e., what functions the subsystems perform and with which physical objects the system design is realized — this is determined independently by the project team, the client usually being more interested in the supersystem, which for them is a "transparent box," whereas the target system is a "black box." Moreover, this often doesn't happen in one go, but over a long period — and continues even after the first version (MVP, minimal viable product) has been produced and started being used. Often, the most interesting ideas from both client agents in their various roles and from agents-executors of this order come up after the MVP's appearance, during the system's subsequent development.

**Architectural decisions** about how the system is divided into structural parts (modules) and how these modules will interact to keep the architectural characteristic values within acceptable limits (for example, the system, during improvements, remains easily modifiable) are called **architecture.** Note: Architecture is decisions on the system's arrangement in terms of structure (modules/constructs and their connection method), and the system concept is also about the system's arrangement but includes functional objects, and structural ones as affordances for functional objects, as well as spatial (layout/location/allocation) aspects and leads to the overall cost of ownership, and may also include other important aspects (for example, separately highlighted ethical and legal considerations or aesthetic and artistic considerations, which may feature distinct aspects in each project).

The system concept is not architecture (although a decade ago it was considered that architects develop the system concept), and architecture is not the system concept. The system's functionality in the supersystem is determined by the system concept decisions, whereas important characteristics such as "system's ability to evolve, ease of design changes" are determined by architectural decisions.

**Architectural decisions/architecture decision** **records** can be formatted in many ways, for example, structured descriptions on several pages as **architecture decision records**. Architectural decisions are presented as a list of such records or some table with material from these records. Architecture is not a "diagram." Diagrams in the project are mostly not architectural, and if found in some architectural decision, they are used purely for illustrative purposes and do not express architectural decisions. Don't confuse **system architecture** with **building architecture**, where the primary focus is on the building's exterior, and the main skill for the architect is drawing.

More about architectural decisions and their recording is discussed in "Systems Engineering," but the main thing to remember is: **you cannot say anything about a "transparent box"** **(neither discuss the system concept nor the system architecture) until you find out about the "black box," i.e., the system's behavior in its environment.** **If you don't know what a sepulka does, you won't be able to say anything about how it might be arranged!**

This is the main thing to remember in systems thinking: the first consideration of the system is the usage concept, not the system concept, nor the system architecture. First, look from the system boundary into the surrounding world, in the environment at the moment of operation (if you are developing the system, you must imagine this, as operation will be in the future), and consider the system's behavior/function. Only then start looking at the transparent box. If we begin examining the gears in a mechanical clock, then suddenly look at the clock's environment, we might see that these clocks are located in a rocket and should count milliseconds while operating properly with 30G acceleration, because everything vibrates near the engine where these clocks are mounted. Forget about the gears from that moment, it was wasted time! **First look around, from the system boundary outward at the moment of operation, then inside the system at the time of operation, and only then inside the system when it's being created!**

In any case, all these system descriptions (usage concept, system concept, and architectural decisions) are hypotheses, be prepared to change them, negotiate, propose your options, and carefully listen to the options proposed by external project roles. Always substantiate your arguments. "Because I want so" is not an argument, because today you may want one thing, tomorrow another, or "you misunderstood me, I wanted something else," or another agent in your role might want something different — this "want" should be an informed opinion of the role, not just the agent's simple desire.